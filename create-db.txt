import { Client, Databases } from 'node-appwrite';

const client = new Client()
  .setEndpoint('<ENDPOINT>')
  .setProject('<PROJECT_ID>')
  .setKey('<API_KEY>');

const databases = new Databases(client);
const dbId = '<DB_ID>';

async function createCollections() {
  // Create user_types collection first
  await databases.createCollection(
    dbId, 
    'user_types', 
    'User Types'
  );

  // Add attributes to user_types collection
  await databases.createStringAttribute(dbId, 'user_types', 'label', 255, true);

  // Create users collection
  await databases.createCollection(
    dbId, 
    'users', 
    'Users'
  );

  // Add attributes to users collection
  await databases.createStringAttribute(dbId, 'users', 'first_name', 255, true);
  await databases.createStringAttribute(dbId, 'users', 'last_name', 255, true);
  await databases.createStringAttribute(dbId, 'users', 'username', 255, true);
  // Changed user_type_id to relationship attribute
  await databases.createRelationshipAttribute(
    dbId,
    'users',
    'user_types',
    'manyToOne' as any,
    false,
    'user_type_id',
    undefined,
    'cascade' as any
  );

  // Create statuses collection
  await databases.createCollection(
    dbId, 
    'statuses', 
    'Statuses'
  );

  // Add attributes to statuses collection
  await databases.createStringAttribute(dbId, 'statuses', 'label', 255, true);

  // Create customers collection
  await databases.createCollection(
    dbId, 
    'customers', 
    'Customers'
  );

  // Add attributes to customers collection
  await databases.createStringAttribute(dbId, 'customers', 'name', 255, true);
  await databases.createStringAttribute(dbId, 'customers', 'address', 255, true);
  await databases.createStringAttribute(dbId, 'customers', 'primary_contact_name', 255, true);
  await databases.createStringAttribute(dbId, 'customers', 'primary_contact_number', 255, true);
  await databases.createStringAttribute(dbId, 'customers', 'primary_email', 255, true);
  await databases.createStringAttribute(dbId, 'customers', 'abn', 255, false);

  // Create customer_contacts collection
  await databases.createCollection(
    dbId, 
    'customer_contacts', 
    'Customer Contacts'
  );

  // Add attributes to customer_contacts collection
  // Changed customer_id to relationship attribute
  await databases.createRelationshipAttribute(
    dbId,
    'customer_contacts',
    'customers',
    'manyToMany' as any,
    false,
    'customer_id',
    undefined,
    'cascade' as any
  );
  await databases.createStringAttribute(dbId, 'customer_contacts', 'first_name', 255, true);
  await databases.createStringAttribute(dbId, 'customer_contacts', 'last_name', 255, true);
  await databases.createStringAttribute(dbId, 'customer_contacts', 'position', 255, false);
  await databases.createStringAttribute(dbId, 'customer_contacts', 'contact_number', 255, true);
  await databases.createStringAttribute(dbId, 'customer_contacts', 'email', 255, true);

  // Create tickets collection
  await databases.createCollection(
    dbId, 
    'tickets', 
    'Tickets'
  );

  // Add attributes to tickets collection
  await databases.createRelationshipAttribute(
    dbId,
    'tickets',
    'statuses',
    'manyToOne' as any,
    false,
    'status_id',
    undefined,
    'cascade' as any
  );
  await databases.createRelationshipAttribute(
    dbId,
    'tickets',
    'customers', 
    'manyToOne' as any,
    false,
    'customer_id',
    undefined,
    'cascade' as any
  );
  // Changed assignee_ids to relationship attribute
  await databases.createRelationshipAttribute(
    dbId,
    'tickets',
    'users',
    'manyToMany' as any,
    false,
    'assignee_ids',
    undefined,
    'cascade' as any
  );
  await databases.createFloatAttribute(dbId, 'tickets', 'billable_hours', true);
  await databases.createFloatAttribute(dbId, 'tickets', 'total_hours', true);
  await databases.createStringAttribute(dbId, 'tickets', 'description', 1000, true);
  await databases.createStringAttribute(dbId, 'tickets', 'attachments', 255, false, undefined, true);
}

createCollections().catch(console.error);